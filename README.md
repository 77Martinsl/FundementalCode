# FundementalCode
Easy to go cheat sheet on all the basic codes
Within this github I am storing examples of all these algorithms in pyhton as a learning exercise. No AI allowed as uni will teach me the theory of these but not how to code them.

## 1. Sorting Algorithms

- **Bubble Sort**: Simple but inefficient for large datasets.
- **Merge Sort**: Efficient and uses a divide-and-conquer approach.
- **Quick Sort**:Faster in practice but can be less stable.
- **Insertion Sort**: Great for small or nearly sorted datasets.
- **Heap Sort**: Uses a binary heap data structure.

## 2. Searching Algorithms

- **Linear Search**: Simple but not efficient for large datasets.
- **Binary Search**: Fast but requires a sorted array.
- **Depth-First Search (DFS)**: Explores as far as possible along each branch before backtracking.
- **Breadth-First Search (BFS)**: Explores all neighbors at the present depth before moving on to nodes at the next depth level.

## 3. Graph Algorithms

- **Dijkstra's Algorithm**: For finding the shortest paths between nodes in a graph.
- **Bellman-Ford Algorithm**: Computes shortest paths in a weighted graph.
- **A Search Algorithm**:* An informed search algorithm for finding the shortest path.
- **Kruskal’s Algorithm & Prim’s Algorithm**: For finding the minimum spanning tree.

## 4. Dynamic Programming

- **Knapsack Problem**: Optimizes a set of items to maximize profit.
- **Fibonacci Sequence**: A classic example of overlapping subproblems.
- **Longest Common Subsequence (LCS)**: Finds the longest subsequence common to all sequences in a set.

## 5. Other Important Algorithms

- **Hashing**: For creating a unique hash code for efficient data retrieval.
- **Divide and Conquer**: A general strategy for solving complex problems by breaking them into simpler sub-problems.
-**Recursion**: A method where the solution involves solving smaller instances of the same problem.
